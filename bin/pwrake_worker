#!/usr/bin/env ruby

require "thread"
require "pathname"
require "fileutils"
require 'singleton'

$dbg = true
if $dbg
  $log = File.open("worker-#{`hostname`.chomp}-#{Process.pid}.log","w")
  #$stderr = $log
else
  $log = $stderr
end

module Pwrake

  class Writer
    include Singleton

    def initialize
      @out = $stdout
      @mutex = Mutex.new
    end

    def puts(s)
      @mutex.synchronize do
        begin
          @out.print s+"\n"
          @out.flush
        rescue Errno::EPIPE
        end
        $log.print "<#{s}\n" if $dbg
      end
    end

    def print(s)
      @mutex.synchronize do
        begin
          @out.print s
          @out.flush
        rescue Errno::EPIPE
        end
        $log.print "<#{s}"  if $dbg
      end
    end

    def flush
      @out.flush
    end

    def dputs(s)
      puts(s) if $DEBUG
    end
  end


  class Worker

    @@base_dir = ENV['HOME']
    @@work_dir = nil
    LIST = {}

    def self.base_dir=(d)
      @@base_dir = d
    end

    def self.work_dir=(d)
      @@work_dir = d
    end

    # instance methods

    def dir
      @current_path.to_s
    end

    def initialize(id)
      @id = id
      @queue = Queue.new
      @env = {}
      @out = Writer.instance
      LIST[@id] = self
      setup_threads
      execute "setup_directory"
    end

    def setup_threads
      pipe_in, @pipe_out = IO.pipe
      @out_thread = Thread.new(pipe_in,"#{@id}:") do |pin,pre|
        while s = pin.gets
          @out.print pre+s
        end
      end

      pipe_in2, @pipe_out2 = IO.pipe
      @err_thread = Thread.new(pipe_in2,"#{@id}e:") do |pin,pre|
        while s = pin.gets
          @out.print pre+s
        end
      end

      @exec_thread = Thread.new do
        while cmd = @queue.deq
          begin
            run(cmd)
          rescue => exc
            @out.puts x="end:error:#{exc}"
            $log.puts exc
            $log.puts exc.backtrace.join("\n")
          end
        end
        @pipe_out.flush
        @pipe_out2.flush
        @pipe_out.close
        @pipe_out2.close
      end
    end

    def setup_directory
      @current_path = home_path + @@work_dir
    end

    def run(cmd)
      case cmd
      when Proc
        cmd.call
      when "setup_directory"
        setup_directory
        #
      when "cd"
        cd
        @out.puts "end:#{@id}"
        #
      when /^cd\s+(.*)$/
        cd($1)
        @out.puts "end:#{@id}"
        #
      when "exit"
        close
        @out.puts "end:#{@id}"
        #
      when /^export (\w+)=(.*)$/o
        k,v = $1,$2
        @env[k] = v
        #
      when String
        d = dir()
        if !Dir.exist?(d)
          raise "Directory '#{d}' does not exsit"
        end
        @pid = spawn(@env,cmd,:out=>@pipe_out,:err=>@pipe_out2,:chdir=>d)
        @out.puts "start:#{@id}:#{@pid}"
        pid,status = Process.wait2(@pid)
        @pipe_out.flush
        @pipe_out2.flush
        @out_thread.run
        @err_thread.run
        status_s = status_to_str(status)
        @out.puts x="end:#{@id}:#{@pid}:#{status_s}"
      end
    end

    def status_to_str(s)
      if s.exited?
        x = "#{s.to_i},exited"
      elsif s.signaled?
        x = "#{s.to_i},signaled,signal=#{s.termsig}"
      elsif s.stopped?
        x = "#{s.to_i},stopped,signal=#{s.stopsig}"
      elsif s.coredump?
        x = "#{s.to_i},coredumped"
      end
      return x
    end

    def cd(d='')
      if d==''
        @current_path = home_path
      else
        pn = Pathname(d.sub(/^\$HOME\b/,ENV['HOME']))
        if pn.relative?
          pn = @current_path + pn
        end
        if !Dir.exist?(pn)
          raise "Cannot chdir to #{pn}"
        end
        @current_path = pn.realpath
      end
    end

    def home_path
      Pathname.new(ENV['HOME'])
    end

    def execute(cmd)
      @queue.enq(cmd)
      @exec_thread.run
    end

    def exit
      close
    end

    def close
      execute(nil)
      LIST.delete(@id)
    end

    def join
      @out_thread.join  if @out_thread
      @err_thread.join  if @err_thread
      @exec_thread.join if @exec_thread
    end

    def kill(sig)
      sig = sig.to_i if /^\d+$/=~sig
      Process.kill(sig,@pid)
    end
  end


  class GfarmWorker < Worker
    @@gfarm_top = "/tmp"
    @@gfarm_prefix = nil

    def self.init(prefix)
      @@gfarm_prefix = prefix
      Dir.chdir(ENV['HOME'])
      #@@gfarm_prefix = "#{@@gfarm_top}/pwrake_#{ENV['USER']}_#{Process.pid}_"
      #if !Dir.glob(@@gfarm_prefix+"*").empty?
      #  raise "Already running worker:#{Process.pid}"
      #end
    end

    def initialize(id)
      @gfarm_mountpoint = @@gfarm_prefix % id
      super
    end

    def setup_directory
      FileUtils.mkdir_p @gfarm_mountpoint
      system "gfarm2fs #{@gfarm_mountpoint} >& /dev/null"
      @current_path = home_path + @@work_dir
    end

    def close
      # $log.puts "GfarmWorker.close #{@gfarm_mountpoint}"
      if File.directory? @gfarm_mountpoint
        cd ENV['HOME']
        system "fusermount -u #{@gfarm_mountpoint} >& /dev/null"
        system "sync"
        FileUtils.rmdir @gfarm_mountpoint
        $log.puts "#{@gfarm_mountpoint} is removed"
      end
      super
    end

    def home_path
      Pathname.new(@gfarm_mountpoint)
    end
  end


  class Invoker

    def initialize(args)
      @out = Writer.instance
      @mutex = Mutex.new
      @worker_class = Worker
      @node_id = ARGV[0]
      @ncore = ARGV[1] ? ARGV[1].to_i : count_cpu

      @out.puts "ncore:#{@ncore}"

      at_exit{
        $log.puts "at_exit"
        close_all
      }

      [:TERM,:INT].each do |sig|
        Signal.trap(sig) do
          #close_all # called at_exit
          Kernel.exit
        end
      end

      Signal.trap("PIPE", "EXIT")
    end

    def count_cpu
      ncpu = 0
      open("/proc/cpuinfo").each do |l|
        ncpu += 1 if /^processor\s+: \d+/=~l
      end
      ncpu
    end

    def run
      while line = gets
        line.chomp!
        line.strip!
        $log.print ">#{line}\n"  if $dbg
        case line
        when /^(\d+):(.*)$/o
          id,cmd = $1,$2
          wk = Worker::LIST[id]
          if wk.nil?
            if cmd=="exit"
              @out.puts "end:#{id}"
              next
            else
              wk = @worker_class.new(id)
            end
          end
          wk.execute(cmd)
          #
        when /^p$/o
          puts "Worker::LIST = #{Worker::LIST.inspect}"
          #
        when /^fs:gfarm:(.*)$/o
          GfarmWorker.init($1)
          @worker_class = GfarmWorker
          #
        when /^new:(.*)$/o
          $1.split.each do |id|
            @worker_class.new(id)
          end
          #
        when /^cd:(.*)$/o
          Worker.base_dir=$1
          #
        when /^wd:(.*)$/o
          Worker.work_dir=$1
          #
        when /^export:(\w+)=(.*)$/o
          k,v = $1,$2
          ENV[k] = v
          #
        when /^exit$/o
          return
          #
        when "exit_worker"
          return
          #
        when /^kill:(\d+):(.*)$/o
          id,signal = $1,$2
          worker = Worker::LIST[id]
          worker.kill(signal) if worker
          #
        when /^kill:(.*)$/o
          sig = $1
          sig = sig.to_i if /^\d+$/=~sig
          @out.puts "worker_killed:signal=#{sig}"
          Process.kill(sig, 0)
          #
        else
          raise "invalid line: #{line}"
        end
      end
    end

    def close_all
      $log.puts "close_all"
      Dir.chdir
      id_list = Worker::LIST.keys
      wk_list = Worker::LIST.values
      wk_list.each {|wk| wk.close}
      wk_list.each {|wk| wk.join}
      $log.puts "worker:end:#{id_list.inspect}"
      @out.puts "worker_end"
      $log.flush
    end

  end
end


begin
  Pwrake::Invoker.new(ARGV).run
rescue => exc
  $log.puts exc
  $log.puts exc.backtrace.join("\n")
end
